'''
394 题

我们要想分割每个括号内的内容，分割的标志只能是以"[" or "]" 为准。我曾经尝试过以数字，但是数字并不可靠。因为1可以省略不写。
而如果以 [] 为界的话，就会拆散本该一对的倍数和字母。
例如： 3[a2[c]]  3 应该和a一对，2和c一对。可是如果以[ ] 为分界线，只能把2和a分一起，3和""（啥也没有分一起）。不过没关系，错一位记录也行。
那么公式就应该是：
设stack中是 [ a, 2] , 手里的是c， 则有 a + c * 2

即 pre_res + cur_res * pre_times

这个计算公式只所以成立是因为：
pre_res 与 cur_res 一定是平级关系，因为他们之间用的是 [ 互相连接， a[b 那么a和b之间一定是相加的关系。

这里需要注意的是 你记录的一定是当前的结果，而不是当前手里的东西。

整个程序逻辑清晰：
以[ or ] 为令。
[ push， ] pop
在push之前，把当前计算结果记录下来，当] 出现后，pop 倍数和之前的结果。
res = pre_res + 倍数* 当前结果

这里之所以成立是因为一个性质：即
[ 连接的两个量一定是并列的关系，所以关系用+
例如 c2[a 2[b]]
其中 a和2b的关系并列  c和2[a2[b]]的关系并列。





！！！！！！！！！！
这些东西都是抽象的，我们如何使用好data structure还是要理解逻辑运算与数据结构的共同性。
我们在计算这道题的时候，可以发现，这道题类似于数学的带有括号的乘法和加法的计算。
而数学的括号计算的本质在于：先被括号括起来的外层括号。反而要后算。后被括起来内层括号要先算。这就是堆栈的意义。
我们计算的方法是：例如 2[a4[t]9[ik]]
当我们看到2 和 a 的时候 知道2 * a
可是这时候我们又看到了 4 和 t，就拿着2和a，没办法，算算不了,我们把当前的计算结果记下来即 2 * a [....]
后来我们看到了 t的括号结束了，那么4t就算结束了，作为当前的结果。
后来我们又有9 ik 我们重复4t
我们又看到了], 这时候我们手里的res已经是4[t]9[ik]了，拿起已经被遗忘了的2 a继续算， 2 * [a + 4[t]9[ik]]



这就和堆栈是一样的。
堆栈用来存放的一定是当前无法处理的内容，可是新的信息又来了不得不接的情况下，我们把之前的信息得以放在堆栈里存放。

这道题也是一样的：
首先要保证手里抓着一个事情，然后看事情的发展，如果事情发展结束了，那就结束了。如果发展没有结束，却来新的问题了。那就放下手头的事情，将当前进展放到堆栈里
存放。等待pop的召唤。





这里有个小技巧来区分char和int，就是用不等式， "1" <= x <= "9"  对比的是ASIIC码！！

'''

class Solution:
    def decodeString(self, s: str):
        res, next_num, stack = "", 0, []
        for c in s:
            if c == "[" :   # 新问题又来了, 把同一级别上的目前计算的答案存起来
                stack.append([next_num, res])
                next_num, res = 0, ""
            elif c == "]":
                cur_num, pre_res = stack.pop()
                res = pre_res + cur_num * res
            elif "0" <= c <= "9":
                next_num = next_num * 10 + int(c)
            else:
                res += c

        return res

foo = Solution()
foo.decodeString("100[leetcode]")




