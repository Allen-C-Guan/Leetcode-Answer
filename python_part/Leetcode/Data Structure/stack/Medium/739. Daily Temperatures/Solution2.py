'''
这道题类似于按个头排队的问题。
这里面最大的特点在于：都是
        顺序关系 + 大小关系   混合的问题。

这类题都有一定的去冗余性： 对于本题而言，若有两个元素分别为：位于前面的元素a 和位于后面的元素b, 且a >= b， 那么你会发现一个性质：
对于位于a前面的所有元素而言，b是没有意义的。
因为a即比b大，又比b靠前，a就像一座大山，把b牢牢的挡在后面。因为a的存在，a前面的元素永远看不到也用不到b存在。


我们就可以利用这个性质来解题：
首先我们肯定是采取倒序遍历。因为答案在后面，你从前往后遍历，就需要先上车后补票，很复杂。

这里我们可以用个堆栈，用于递增的存放元素对应的index。

当逆序遍历的过程中时：堆栈里存放这从后往前已经遍历过的内容。
    1. 若当前的元素小于堆栈顶元素，那么这个元素不会挡住任何一个堆栈里的元素，返回1。并把该元素放到堆栈里。
    2. 若当前的元素大于堆栈顶端元素，那么就说明后面一定有元素被挡住了。后面出现了无用的元素。
        1. 把所有小于该元素的元素都pop出去。因为这些元素对于前面的元素而言已经没有用了。
        2. 找到比他大的元素，计算中间间隔几天，并return
上面的可以整合为一个逻辑：
    先把stack的栈顶pop到恰好大于当前的元素的位置上。
    然后把return的是当前元素位置与栈顶恰好比其大的元素之间的距离

需要特殊处理一下 list是empty的情况

'''
from typing import List
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        stack = []
        res = [0 for _ in range(len(T))]
        for i in range(len(T)-1,-1,-1):
            while len(stack) != 0 and T[i] >= T[stack[-1]]:
                stack.pop()
            if len(stack) != 0:
                res[i] = stack[-1] - i
            stack.append(i)
        return res

foo = Solution()
print(foo.dailyTemperatures(
[73,74,75,71,69,72,76,73]))