'''




之前我们用递归的解法，超时，这是由于我们考虑到了内容太多太复杂，不如通过我们抓住问题的中心，去除不需要考虑的部分，简化算法。

对于BST，如果只关心种类的数量的问题，那么有：

        种类的多少只与序列的数量有关，和内容无关！！！！

也就是说，用1234  和  5678 组成的BST的种类虽然不同，但数量完全相同。


之前分析，BST的性质为：

        i
       / \
    left right

left 必然包含且只包含 [1:i-1]的序列， 序列长度为 i-1
right 也必然只包含 [i+1, n] 的序列， 序列长度为 n-i
因此，以i为root的子树的数量是左右子树数量 之积！！ 不是之和！！因为他们是一一配对，每一个左边的都可以和右边的任何一个配成一对。


因此我们可以发现：
    G(n) = f( G(1:n-1) )
    即 如果知道了n-1以下的树的个数，就可以直接求得 n 的树的个数。 因此我么需要寻找他们之间的关系




我们若定义函数 G(n): 表示以[1,n]为list 的 BST 的数量。
定义F(i,n) 表示以i为root，以[1:n] n 个元素作为list 的BST的数量。则有公式
    F(i, n) = G(i-1) * G(n-i)

而我们所求的 G(n) 与 F(i, n) 的关系为：
    for i in range(n+1):
        res = res + F(i)

    res = G(n)


    因此有：
    for i in range(n+1):
        G(n) = G(n) + G(i-1) * G(n-i)



    组合的时候运算是乘， 遍历root的时候运算是 +

    可是这里最大的问题是G(i-1) * G(n-i)中，无法同时实现，因此我们再设计一个循环，用于G(n) 的增长：

    for j in range(2, n+1):
        for i in range(j+1):
            G(j) = G(j) + G(i-1) * G(j-i)

    当j遍历到n的时候答案就得到了

设计DP：
1. 定义状态：
    定义函数 G(n): 表示以[1,n]为list 的 BST 的数量。
    定义F(i,n) 表示以i为root，以[1:n] n 个元素作为list 的BST的数量

2. 转移方程：
    for j in range(2, n+1):
        for i in range(j+1):
            G(j) = G(j) + G(i-1) * G(j-i)


3. 边界条件：
    G(0) = 1  没有元素当时候，tree的结构只有1种。
    G(1) = 1   只有一个元素的时候，tree的结构也只有一种。
    F(2) = G(1）+ G(0) 就可以开始DP计算了。

'''


class Solution:
    def numTrees(self, n):

        G = [0]*(n+1)
        G[0], G[1] = 1, 1

        for i in range(2, n+1):
            for j in range(1, i+1):
                G[i] += G[j-1] * G[i-j]

        return G[n]


